// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel ApplyGravity
#pragma kernel Constraints

struct Point
{
	float2 Position, PrevPosition;
	int Locked;
};
struct Stick
{
	uint A, B;
	float Length;
};

RWStructuredBuffer<Point> Points;
RWStructuredBuffer<Stick> Sticks;
uint PointsLength;
uint SticksLength;
float DeltaTime;
float2 Gravity;

[numthreads(1,1,1)]
void ApplyGravity (uint3 id : SV_DispatchThreadID)
{
	Point p = Points[id.x];
	float2 oldPos = p.Position;
	p.Position += (p.Position - p.PrevPosition) * (1 - p.Locked);
	p.Position += Gravity * DeltaTime * DeltaTime * (1 - p.Locked);
	p.PrevPosition = oldPos;

	Points[id.x] = p;
}

[numthreads(1,1,1)]
void Constraints (uint3 id : SV_DispatchThreadID)
{
	Point p = Points[id.x];

	for (int j = 0; j < SticksLength; j++) {
		float actualLength = distance(Points[Sticks[j].A].Position, Points[Sticks[j].B].Position);
		float lengthDelta = Sticks[j].Length - actualLength;
		float2 stickDir = normalize(Points[Sticks[j].A].Position - Points[Sticks[j].B].Position);

		if (Sticks[j].A == id.x && !Points[id.x].Locked) {
			p.Position += stickDir * lengthDelta / 2;
		}
		if (Sticks[j].B == id.x && !Points[id.x].Locked) {
			p.Position -= stickDir * lengthDelta / 2;
		}
	}

	Points[id.x] = p;
}
